diff --git a/node_modules/@radix-ui/react-tooltip/dist/index.js b/node_modules/@radix-ui/react-tooltip/dist/index.js
index d1fd765..c8f76a8 100644
--- a/node_modules/@radix-ui/react-tooltip/dist/index.js
+++ b/node_modules/@radix-ui/react-tooltip/dist/index.js
@@ -1,2 +1,2 @@
-var e=require("@radix-ui/react-id").useId,t=O({},require("@radix-ui/react-visually-hidden")),r=require("@radix-ui/react-slot").Slottable,n=require("@radix-ui/react-portal").Portal,o=O({},require("@radix-ui/react-popper")),i=require("@radix-ui/react-primitive"),a=i.Primitive,u=i.extendPrimitive,c=require("@radix-ui/react-use-rect").useRect,s=require("@radix-ui/react-use-previous").usePrevious,l=require("@radix-ui/react-use-layout-effect").useLayoutEffect,d=require("@radix-ui/react-use-controllable-state").useControllableState,f=require("@radix-ui/react-context").createContext,p=require("@radix-ui/react-compose-refs").useComposedRefs,v=require("@radix-ui/primitive").composeEventHandlers,E=O({},require("react"));function O(e,t){return Object.keys(t).forEach((function(r){"default"!==r&&"__esModule"!==r&&Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[r]}})})),e}var m,S;function b(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function y(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?b(Object(r),!0).forEach((function(t){g(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):b(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function g(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function I(){return(I=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}function T(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}function x(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var r=[],n=!0,o=!1,i=void 0;try{for(var a,u=e[Symbol.iterator]();!(n=(a=u.next()).done)&&(r.push(a.value),!t||r.length!==t);n=!0);}catch(e){o=!0,i=e}finally{try{n||null==u.return||u.return()}finally{if(o)throw i}}return r}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return C(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);"Object"===r&&e.constructor&&(r=e.constructor.name);if("Map"===r||"Set"===r)return Array.from(e);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return C(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function C(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var D=function(e){var t,r,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=n.debug,i=void 0!==o&&o,a=n.warnOnUnknownTransitions,u=void 0!==a&&a,c=e.initial,s=e.context,l=[];function d(e){return l.push(e),function(){l.splice(l.indexOf(e),1)}}function f(){l.forEach((function(e){return e({state:c,previousState:t,context:s})}))}var p=function n(o,a){var l=e.states[c],d=l.on&&l.on[o];if(void 0===d)u&&console.warn('From state: "'.concat(c,'", event "').concat(o,'" does not lead to any state'));else{t=c,r=s,l.onLeaveState&&l.onLeaveState(n);var p=e.states[d];p.onEnterState&&p.onEnterState(n),c=d,void 0!==a&&(s=a),i&&console.log({previousState:t,previousContext:r,event:o,state:c,context:s}),f()}};function v(){return c}function E(){return s}return{subscribe:d,transition:p,getState:v,getContext:E}}({initial:"CLOSED",context:{id:null},states:{CLOSED:{on:{mouseEntered:"WAITING_FOR_REST",focused:"OPEN"}},WAITING_FOR_REST:{onEnterState:function(e){clearTimeout(m),m=window.setTimeout((function(){return e("restTimerElapsed")}),300)},onLeaveState:function(){clearTimeout(m)},on:{restTimerElapsed:"OPEN",mouseMoved:"WAITING_FOR_REST",mouseLeft:"CLOSED",activated:"DISMISSED",unmounted:"CLOSED"}},OPEN:{on:{mouseLeft:"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD",mouseEntered:"OPEN",mouseMoved:"OPEN",activated:"DISMISSED",blurred:"CLOSED",triggerMoved:"CLOSED",unmounted:"CLOSED"}},CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD:{onEnterState:function(e){clearTimeout(S),S=window.setTimeout((function(){return e("skipRestTimerElapsed")}),300)},onLeaveState:function(){clearTimeout(S)},on:{skipRestTimerElapsed:"CLOSED",mouseEntered:"OPEN",focused:"OPEN",activated:"DISMISSED",unmounted:"CLOSED"}},DISMISSED:{on:{mouseLeft:"CLOSED",blurred:"CLOSED",unmounted:"CLOSED"}}}}),h=x(f("Tooltip"),2),w=h[0],R=h[1],L=function(t){var r=t.children,n=t.open,o=t.defaultOpen,i=void 0!==o&&o,a=t.onOpenChange,u=E.useRef(null),c=e(),s=x(d({prop:n,defaultProp:i,onChange:a}),2),f=s[0],p=void 0!==f&&f,v=s[1],O=x(E.useState(n?"instant-open":"closed"),2),m=O[0],S=O[1];return E.useEffect((function(){return D.subscribe((function(e){var t=e.state,r=e.context;"OPEN"===t&&r.id===c?v(!0):v(!1)}))}),[c,v]),E.useEffect((function(){return D.subscribe((function(e){var t=e.state,r=e.previousState;"OPEN"===t&&("WAITING_FOR_REST"===r&&S("delayed-open"),"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD"!==r&&"CLOSED"!==r||S("instant-open")),"CLOSED"===t&&S("closed")}))}),[]),E.useEffect((function(){return function(){D.transition("unmounted",{id:c})}}),[c]),l((function(){!0===n&&D.transition("mouseEntered",{id:c})}),[c,n]),E.createElement(w,{triggerRef:u,contentId:c,open:p,stateAttribute:m},r)};exports.Tooltip=L,L.displayName="Tooltip";var P=E.forwardRef((function(e,t){var r=e.as,n=void 0===r?"button":r,o=T(e,["as"]),i=R("TooltipTrigger"),u=p(t,i.triggerRef);return E.createElement(a,I({type:"button","aria-describedby":i.open?i.contentId:void 0,"data-state":i.stateAttribute},o,{as:n,ref:u,onMouseEnter:v(e.onMouseEnter,(function(){return D.transition("mouseEntered",{id:i.contentId})})),onMouseMove:v(e.onMouseMove,(function(){return D.transition("mouseMoved",{id:i.contentId})})),onMouseLeave:v(e.onMouseLeave,(function(){D.getContext().id===i.contentId&&D.transition("mouseLeft",{id:i.contentId})})),onFocus:v(e.onFocus,(function(){return D.transition("focused",{id:i.contentId})})),onBlur:v(e.onBlur,(function(){D.getContext().id===i.contentId&&D.transition("blurred",{id:i.contentId})})),onMouseDown:v(e.onMouseDown,(function(){return D.transition("activated",{id:i.contentId})})),onKeyDown:v(e.onKeyDown,(function(e){"Escape"!==e.key&&"Enter"!==e.key&&" "!==e.key||D.transition("activated",{id:i.contentId})}))}))}));exports.TooltipTrigger=P,P.displayName="TooltipTrigger";var _=E.forwardRef((function(e,t){return R("TooltipContent").open?E.createElement(j,I({ref:t},e)):null}));exports.TooltipContent=_;var j=E.forwardRef((function(e,i){var a=e.children,u=e["aria-label"],c=e.anchorRef,s=e.portalled,l=void 0===s||s,d=T(e,["children","aria-label","anchorRef","portalled"]),f=R("TooltipContent"),p=l?n:E.Fragment;return E.createElement(p,null,E.createElement(N,null),E.createElement(o.Root,I({"data-state":f.stateAttribute},d,{ref:i,anchorRef:c||f.triggerRef,style:y(y({},d.style),{},g({},"--radix-tooltip-content-transform-origin","var(--radix-popper-transform-origin)"))}),E.createElement(r,null,a),E.createElement(t.Root,{id:f.contentId,role:"tooltip"},u||a)))}));_.displayName="TooltipContent";var M=u(o.Arrow,{displayName:"TooltipArrow"});function N(){var e=R("CheckTriggerMoved"),t=c(e.triggerRef),r=null==t?void 0:t.left,n=s(r),o=null==t?void 0:t.top,i=s(o);return E.useEffect((function(){(void 0!==n&&n!==r||void 0!==i&&i!==o)&&D.transition("triggerMoved",{id:e.contentId})}),[e.contentId,n,i,r,o]),null}exports.TooltipArrow=M;var A=L;exports.Root=A;var q=P;exports.Trigger=q;var H=_;exports.Content=H;var F=M;exports.Arrow=F;
+var e=require("@radix-ui/react-id").useId,t=O({},require("@radix-ui/react-visually-hidden")),r=require("@radix-ui/react-slot").Slottable,n=require("@radix-ui/react-portal").Portal,o=O({},require("@radix-ui/react-popper")),i=require("@radix-ui/react-primitive"),a=i.Primitive,u=i.extendPrimitive,c=require("@radix-ui/react-use-rect").useRect,s=require("@radix-ui/react-use-previous").usePrevious,l=require("@radix-ui/react-use-layout-effect").useLayoutEffect,d=require("@radix-ui/react-use-controllable-state").useControllableState,f=require("@radix-ui/react-context").createContext,p=require("@radix-ui/react-compose-refs").useComposedRefs,v=require("@radix-ui/primitive").composeEventHandlers,E=O({},require("react"));function O(e,t){return Object.keys(t).forEach((function(r){"default"!==r&&"__esModule"!==r&&Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[r]}})})),e}var m,S;function b(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function y(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?b(Object(r),!0).forEach((function(t){g(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):b(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function g(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function I(){return(I=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}function T(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}function x(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var r=[],n=!0,o=!1,i=void 0;try{for(var a,u=e[Symbol.iterator]();!(n=(a=u.next()).done)&&(r.push(a.value),!t||r.length!==t);n=!0);}catch(e){o=!0,i=e}finally{try{n||null==u.return||u.return()}finally{if(o)throw i}}return r}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return C(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);"Object"===r&&e.constructor&&(r=e.constructor.name);if("Map"===r||"Set"===r)return Array.from(e);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return C(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function C(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var D=function(e){var t,r,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=n.debug,i=void 0!==o&&o,a=n.warnOnUnknownTransitions,u=void 0!==a&&a,c=e.initial,s=e.context,l=[];function d(e){return l.push(e),function(){l.splice(l.indexOf(e),1)}}function f(){l.forEach((function(e){return e({state:c,previousState:t,context:s})}))}var p=function n(o,a){var l=e.states[c],d=l.on&&l.on[o];if(void 0===d)u&&console.warn('From state: "'.concat(c,'", event "').concat(o,'" does not lead to any state'));else{t=c,r=s,l.onLeaveState&&l.onLeaveState(n);var p=e.states[d];p.onEnterState&&p.onEnterState(n),c=d,void 0!==a&&(s=a),i&&console.log({previousState:t,previousContext:r,event:o,state:c,context:s}),f()}};function v(){return c}function E(){return s}return{subscribe:d,transition:p,getState:v,getContext:E}}({initial:"CLOSED",context:{id:null},states:{CLOSED:{on:{mouseEntered:"WAITING_FOR_REST",focused:"OPEN"}},WAITING_FOR_REST:{onEnterState:function(e){clearTimeout(m),m=window.setTimeout((function(){return e("restTimerElapsed")}),200)},onLeaveState:function(){clearTimeout(m)},on:{restTimerElapsed:"OPEN",mouseMoved:"WAITING_FOR_REST",mouseLeft:"CLOSED",activated:"DISMISSED",unmounted:"CLOSED"}},OPEN:{on:{mouseLeft:"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD",mouseEntered:"OPEN",mouseMoved:"OPEN",activated:"DISMISSED",blurred:"CLOSED",triggerMoved:"CLOSED",unmounted:"CLOSED"}},CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD:{onEnterState:function(e){clearTimeout(S),S=window.setTimeout((function(){return e("skipRestTimerElapsed")}),200)},onLeaveState:function(){clearTimeout(S)},on:{skipRestTimerElapsed:"CLOSED",mouseEntered:"OPEN",focused:"OPEN",activated:"DISMISSED",unmounted:"CLOSED"}},DISMISSED:{on:{mouseLeft:"CLOSED",blurred:"CLOSED",unmounted:"CLOSED"}}}}),h=x(f("Tooltip"),2),w=h[0],R=h[1],L=function(t){var r=t.children,n=t.open,o=t.defaultOpen,i=void 0!==o&&o,a=t.onOpenChange,u=E.useRef(null),c=e(),s=x(d({prop:n,defaultProp:i,onChange:a}),2),f=s[0],p=void 0!==f&&f,v=s[1],O=x(E.useState(n?"instant-open":"closed"),2),m=O[0],S=O[1];return E.useEffect((function(){return D.subscribe((function(e){var t=e.state,r=e.context;"OPEN"===t&&r.id===c?v(!0):v(!1)}))}),[c,v]),E.useEffect((function(){return D.subscribe((function(e){var t=e.state,r=e.previousState;"OPEN"===t&&("WAITING_FOR_REST"===r&&S("delayed-open"),"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD"!==r&&"CLOSED"!==r||S("instant-open")),"CLOSED"===t&&S("closed")}))}),[]),E.useEffect((function(){return function(){D.transition("unmounted",{id:c})}}),[c]),l((function(){!0===n&&D.transition("mouseEntered",{id:c})}),[c,n]),E.createElement(w,{triggerRef:u,contentId:c,open:p,stateAttribute:m},r)};exports.Tooltip=L,L.displayName="Tooltip";var P=E.forwardRef((function(e,t){var r=e.as,n=void 0===r?"button":r,o=T(e,["as"]),i=R("TooltipTrigger"),u=p(t,i.triggerRef);return E.createElement(a,I({type:"button","aria-describedby":i.open?i.contentId:void 0,"data-state":i.stateAttribute},o,{as:n,ref:u,onMouseEnter:v(e.onMouseEnter,(function(){return D.transition("mouseEntered",{id:i.contentId})})),onMouseMove:v(e.onMouseMove,(function(){return D.transition("mouseMoved",{id:i.contentId})})),onMouseLeave:v(e.onMouseLeave,(function(){D.getContext().id===i.contentId&&D.transition("mouseLeft",{id:i.contentId})})),onFocus:v(e.onFocus,(function(){return D.transition("focused",{id:i.contentId})})),onBlur:v(e.onBlur,(function(){D.getContext().id===i.contentId&&D.transition("blurred",{id:i.contentId})})),onMouseDown:v(e.onMouseDown,(function(){return D.transition("activated",{id:i.contentId})})),onKeyDown:v(e.onKeyDown,(function(e){"Escape"!==e.key&&"Enter"!==e.key&&" "!==e.key||D.transition("activated",{id:i.contentId})}))}))}));exports.TooltipTrigger=P,P.displayName="TooltipTrigger";var _=E.forwardRef((function(e,t){return R("TooltipContent").open?E.createElement(j,I({ref:t},e)):null}));exports.TooltipContent=_;var j=E.forwardRef((function(e,i){var a=e.children,u=e["aria-label"],c=e.anchorRef,s=e.portalled,l=void 0===s||s,d=T(e,["children","aria-label","anchorRef","portalled"]),f=R("TooltipContent"),p=l?n:E.Fragment;return E.createElement(p,null,E.createElement(N,null),E.createElement(o.Root,I({"data-state":f.stateAttribute},d,{ref:i,anchorRef:c||f.triggerRef,style:y(y({},d.style),{},g({},"--radix-tooltip-content-transform-origin","var(--radix-popper-transform-origin)"))}),E.createElement(r,null,a),E.createElement(t.Root,{id:f.contentId,role:"tooltip"},u||a)))}));_.displayName="TooltipContent";var M=u(o.Arrow,{displayName:"TooltipArrow"});function N(){var e=R("CheckTriggerMoved"),t=c(e.triggerRef),r=null==t?void 0:t.left,n=s(r),o=null==t?void 0:t.top,i=s(o);return E.useEffect((function(){(void 0!==n&&n!==r||void 0!==i&&i!==o)&&D.transition("triggerMoved",{id:e.contentId})}),[e.contentId,n,i,r,o]),null}exports.TooltipArrow=M;var A=L;exports.Root=A;var q=P;exports.Trigger=q;var H=_;exports.Content=H;var F=M;exports.Arrow=F;
 //# sourceMappingURL=index.js.map
diff --git a/node_modules/@radix-ui/react-tooltip/dist/index.js.map b/node_modules/@radix-ui/react-tooltip/dist/index.js.map
index ce9fa42..69ee211 100644
--- a/node_modules/@radix-ui/react-tooltip/dist/index.js.map
+++ b/node_modules/@radix-ui/react-tooltip/dist/index.js.map
@@ -1 +1 @@
-{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 300;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 300;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Primitive, extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipProvider, useTooltipContext] = createContext<TooltipContextValue>(TOOLTIP_NAME);\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id: contentId });\n    };\n  }, [contentId]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <TooltipProvider\n      triggerRef={triggerRef}\n      contentId={contentId}\n      open={open}\n      stateAttribute={stateAttribute}\n    >\n      {children}\n    </TooltipProvider>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const { as = TRIGGER_DEFAULT_TAG, ...triggerProps } = props;\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      type=\"button\"\n      aria-describedby={context.open ? context.contentId : undefined}\n      data-state={context.stateAttribute}\n      {...triggerProps}\n      as={as}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.contentId })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.contentId })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('mouseLeft', { id: context.contentId });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.contentId })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('blurred', { id: context.contentId });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.contentId })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.contentId });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Polymorphic.Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        data-state={context.stateAttribute}\n        {...contentProps}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        <Slottable>{children}</Slottable>\n        <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHiddenPrimitive.Root>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'TooltipArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const context = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(context.triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolledâ€¦\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id: context.contentId });\n    }\n  }, [context.contentId, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["$parcel$exportWildcard","dest","source","Object","keys","forEach","key","defineProperty","enumerable","get","restTimerId","skipRestTimerId","stateMachine","stateChart","PREVIOUS_STATE","PREVIOUS_CONTEXT","_ref","arguments","length","undefined","_ref$debug","debug","_ref$warnOnUnknownTra","warnOnUnknownTransitions","CURRENT_STATE","initial","CURRENT_CONTEXT","context","subscriptions","subscribe","callback","push","splice","indexOf","notify","state","previousState","transition","event","stateDefinition","states","nextState","on","console","warn","concat","onLeaveState","nextStateDefinition","onEnterState","log","previousContext","getState","getContext","$e635218480c28d9f27af72d31e573b83$export$createStateMachine","id","CLOSED","mouseEntered","focused","WAITING_FOR_REST","clearTimeout","window","setTimeout","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerElapsed","DISMISSED","createContext","TooltipProvider","useTooltipContext","Tooltip","props","children","openProp","open","_props$defaultOpen","defaultOpen","onOpenChange","triggerRef","React","useRef","contentId","useId","_useControllableState2","$bfd2ef98f93cfd0786881e49eeb6a4$var$_slicedToArray","useControllableState","prop","defaultProp","onChange","_useControllableState3","setOpen","_React$useState2","useState","stateAttribute","setStateAttribute","useEffect","_ref2","useLayoutEffect","_react","createElement","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipProvider","displayName","TooltipTrigger","forwardRef","forwardedRef","_props$as","as","triggerProps","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectWithoutProperties","composedTriggerRef","useComposedRefs","Primitive","$bfd2ef98f93cfd0786881e49eeb6a4$var$_extends","type","aria-describedby","data-state","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","TooltipContent","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipContentImpl","TooltipContentImpl","ariaLabel","anchorRef","_props$portalled","portalled","contentProps","PortalWrapper","Portal","Fragment","$bfd2ef98f93cfd0786881e49eeb6a4$var$CheckTriggerMoved","_radixUiReactPopper","Root","style","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectSpread","$bfd2ef98f93cfd0786881e49eeb6a4$var$_defineProperty","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","extendPrimitive","PopperPrimitive","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.js.map"}
\ No newline at end of file
+{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 200;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 200;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Primitive, extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipProvider, useTooltipContext] = createContext<TooltipContextValue>(TOOLTIP_NAME);\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id: contentId });\n    };\n  }, [contentId]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <TooltipProvider\n      triggerRef={triggerRef}\n      contentId={contentId}\n      open={open}\n      stateAttribute={stateAttribute}\n    >\n      {children}\n    </TooltipProvider>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const { as = TRIGGER_DEFAULT_TAG, ...triggerProps } = props;\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      type=\"button\"\n      aria-describedby={context.open ? context.contentId : undefined}\n      data-state={context.stateAttribute}\n      {...triggerProps}\n      as={as}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.contentId })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.contentId })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('mouseLeft', { id: context.contentId });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.contentId })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('blurred', { id: context.contentId });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.contentId })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.contentId });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Polymorphic.Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        data-state={context.stateAttribute}\n        {...contentProps}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        <Slottable>{children}</Slottable>\n        <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHiddenPrimitive.Root>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'TooltipArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const context = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(context.triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolledâ€¦\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id: context.contentId });\n    }\n  }, [context.contentId, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["$parcel$exportWildcard","dest","source","Object","keys","forEach","key","defineProperty","enumerable","get","restTimerId","skipRestTimerId","stateMachine","stateChart","PREVIOUS_STATE","PREVIOUS_CONTEXT","_ref","arguments","length","undefined","_ref$debug","debug","_ref$warnOnUnknownTra","warnOnUnknownTransitions","CURRENT_STATE","initial","CURRENT_CONTEXT","context","subscriptions","subscribe","callback","push","splice","indexOf","notify","state","previousState","transition","event","stateDefinition","states","nextState","on","console","warn","concat","onLeaveState","nextStateDefinition","onEnterState","log","previousContext","getState","getContext","$e635218480c28d9f27af72d31e573b83$export$createStateMachine","id","CLOSED","mouseEntered","focused","WAITING_FOR_REST","clearTimeout","window","setTimeout","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerElapsed","DISMISSED","createContext","TooltipProvider","useTooltipContext","Tooltip","props","children","openProp","open","_props$defaultOpen","defaultOpen","onOpenChange","triggerRef","React","useRef","contentId","useId","_useControllableState2","$bfd2ef98f93cfd0786881e49eeb6a4$var$_slicedToArray","useControllableState","prop","defaultProp","onChange","_useControllableState3","setOpen","_React$useState2","useState","stateAttribute","setStateAttribute","useEffect","_ref2","useLayoutEffect","_react","createElement","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipProvider","displayName","TooltipTrigger","forwardRef","forwardedRef","_props$as","as","triggerProps","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectWithoutProperties","composedTriggerRef","useComposedRefs","Primitive","$bfd2ef98f93cfd0786881e49eeb6a4$var$_extends","type","aria-describedby","data-state","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","TooltipContent","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipContentImpl","TooltipContentImpl","ariaLabel","anchorRef","_props$portalled","portalled","contentProps","PortalWrapper","Portal","Fragment","$bfd2ef98f93cfd0786881e49eeb6a4$var$CheckTriggerMoved","_radixUiReactPopper","Root","style","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectSpread","$bfd2ef98f93cfd0786881e49eeb6a4$var$_defineProperty","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","extendPrimitive","PopperPrimitive","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.js.map"}
diff --git a/node_modules/@radix-ui/react-tooltip/dist/index.module.js b/node_modules/@radix-ui/react-tooltip/dist/index.module.js
index 743f52e..5229dcd 100644
--- a/node_modules/@radix-ui/react-tooltip/dist/index.module.js
+++ b/node_modules/@radix-ui/react-tooltip/dist/index.module.js
@@ -1,2 +1,2 @@
-import{useId as t}from"@radix-ui/react-id";import*as e from"@radix-ui/react-visually-hidden";import{Slottable as o}from"@radix-ui/react-slot";import{Portal as n}from"@radix-ui/react-portal";import*as r from"@radix-ui/react-popper";import{Primitive as i,extendPrimitive as a}from"@radix-ui/react-primitive";import{useRect as s}from"@radix-ui/react-use-rect";import{usePrevious as u}from"@radix-ui/react-use-previous";import{useLayoutEffect as c}from"@radix-ui/react-use-layout-effect";import{useControllableState as d}from"@radix-ui/react-use-controllable-state";import{createContext as l}from"@radix-ui/react-context";import{useComposedRefs as p}from"@radix-ui/react-compose-refs";import{composeEventHandlers as m}from"@radix-ui/primitive";import*as E from"react";let f,S;function T(){return(T=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var o=arguments[e];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(t[n]=o[n])}return t}).apply(this,arguments)}const v=function(t,{debug:e=!1,warnOnUnknownTransitions:o=!1}={}){let n,r,i=t.initial,a=t.context;const s=[],u=(c,d)=>{const l=t.states[i],p=l.on&&l.on[c];if(void 0===p)o&&console.warn('From state: "'.concat(i,'", event "').concat(c,'" does not lead to any state'));else{n=i,r=a,l.onLeaveState&&l.onLeaveState(u);const o=t.states[p];o.onEnterState&&o.onEnterState(u),i=p,void 0!==d&&(a=d),e&&console.log({previousState:n,previousContext:r,event:c,state:i,context:a}),s.forEach((t=>t({state:i,previousState:n,context:a})))}};return{subscribe:function(t){return s.push(t),()=>{s.splice(s.indexOf(t),1)}},transition:u,getState:function(){return i},getContext:function(){return a}}}({initial:"CLOSED",context:{id:null},states:{CLOSED:{on:{mouseEntered:"WAITING_FOR_REST",focused:"OPEN"}},WAITING_FOR_REST:{onEnterState:function(t){clearTimeout(f),f=window.setTimeout((()=>t("restTimerElapsed")),300)},onLeaveState:function(){clearTimeout(f)},on:{restTimerElapsed:"OPEN",mouseMoved:"WAITING_FOR_REST",mouseLeft:"CLOSED",activated:"DISMISSED",unmounted:"CLOSED"}},OPEN:{on:{mouseLeft:"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD",mouseEntered:"OPEN",mouseMoved:"OPEN",activated:"DISMISSED",blurred:"CLOSED",triggerMoved:"CLOSED",unmounted:"CLOSED"}},CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD:{onEnterState:function(t){clearTimeout(S),S=window.setTimeout((()=>t("skipRestTimerElapsed")),300)},onLeaveState:function(){clearTimeout(S)},on:{skipRestTimerElapsed:"CLOSED",mouseEntered:"OPEN",focused:"OPEN",activated:"DISMISSED",unmounted:"CLOSED"}},DISMISSED:{on:{mouseLeft:"CLOSED",blurred:"CLOSED",unmounted:"CLOSED"}}}}),[O,g]=l("Tooltip");export const Tooltip=e=>{const{children:o,open:n,defaultOpen:r=!1,onOpenChange:i}=e,a=E.useRef(null),s=t(),[u=!1,l]=d({prop:n,defaultProp:r,onChange:i}),[p,m]=E.useState(n?"instant-open":"closed");return E.useEffect((()=>v.subscribe((({state:t,context:e})=>{"OPEN"===t&&e.id===s?l(!0):l(!1)}))),[s,l]),E.useEffect((()=>v.subscribe((({state:t,previousState:e})=>{"OPEN"===t&&("WAITING_FOR_REST"===e&&m("delayed-open"),"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD"!==e&&"CLOSED"!==e||m("instant-open")),"CLOSED"===t&&m("closed")}))),[]),E.useEffect((()=>()=>{v.transition("unmounted",{id:s})}),[s]),c((()=>{!0===n&&v.transition("mouseEntered",{id:s})}),[s,n]),E.createElement(O,{triggerRef:a,contentId:s,open:u,stateAttribute:p},o)};Tooltip.displayName="Tooltip";const I="button";export const TooltipTrigger=E.forwardRef(((t,e)=>{const{as:o=I,...n}=t,r=g("TooltipTrigger"),a=p(e,r.triggerRef);return E.createElement(i,T({type:"button","aria-describedby":r.open?r.contentId:void 0,"data-state":r.stateAttribute},n,{as:o,ref:a,onMouseEnter:m(t.onMouseEnter,(()=>v.transition("mouseEntered",{id:r.contentId}))),onMouseMove:m(t.onMouseMove,(()=>v.transition("mouseMoved",{id:r.contentId}))),onMouseLeave:m(t.onMouseLeave,(()=>{v.getContext().id===r.contentId&&v.transition("mouseLeft",{id:r.contentId})})),onFocus:m(t.onFocus,(()=>v.transition("focused",{id:r.contentId}))),onBlur:m(t.onBlur,(()=>{v.getContext().id===r.contentId&&v.transition("blurred",{id:r.contentId})})),onMouseDown:m(t.onMouseDown,(()=>v.transition("activated",{id:r.contentId}))),onKeyDown:m(t.onKeyDown,(t=>{"Escape"!==t.key&&"Enter"!==t.key&&" "!==t.key||v.transition("activated",{id:r.contentId})}))}))}));TooltipTrigger.displayName="TooltipTrigger";export const TooltipContent=E.forwardRef(((t,e)=>g("TooltipContent").open?E.createElement(x,T({ref:e},t)):null));const x=E.forwardRef(((t,i)=>{const{children:a,"aria-label":s,anchorRef:u,portalled:c=!0,...d}=t,l=g("TooltipContent"),p=c?n:E.Fragment;return E.createElement(p,null,E.createElement(C,null),E.createElement(r.Root,T({"data-state":l.stateAttribute},d,{ref:i,anchorRef:u||l.triggerRef,style:{...d.style,"--radix-tooltip-content-transform-origin":"var(--radix-popper-transform-origin)"}}),E.createElement(o,null,a),E.createElement(e.Root,{id:l.contentId,role:"tooltip"},s||a)))}));TooltipContent.displayName="TooltipContent";export const TooltipArrow=a(r.Arrow,{displayName:"TooltipArrow"});function C(){const t=g("CheckTriggerMoved"),e=s(t.triggerRef),o=null==e?void 0:e.left,n=u(o),r=null==e?void 0:e.top,i=u(r);return E.useEffect((()=>{(void 0!==n&&n!==o||void 0!==i&&i!==r)&&v.transition("triggerMoved",{id:t.contentId})}),[t.contentId,n,i,o,r]),null}export const Root=Tooltip;export const Trigger=TooltipTrigger;export const Content=TooltipContent;export const Arrow=TooltipArrow;
+import{useId as t}from"@radix-ui/react-id";import*as e from"@radix-ui/react-visually-hidden";import{Slottable as o}from"@radix-ui/react-slot";import{Portal as n}from"@radix-ui/react-portal";import*as r from"@radix-ui/react-popper";import{Primitive as i,extendPrimitive as a}from"@radix-ui/react-primitive";import{useRect as s}from"@radix-ui/react-use-rect";import{usePrevious as u}from"@radix-ui/react-use-previous";import{useLayoutEffect as c}from"@radix-ui/react-use-layout-effect";import{useControllableState as d}from"@radix-ui/react-use-controllable-state";import{createContext as l}from"@radix-ui/react-context";import{useComposedRefs as p}from"@radix-ui/react-compose-refs";import{composeEventHandlers as m}from"@radix-ui/primitive";import*as E from"react";let f,S;function T(){return(T=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var o=arguments[e];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(t[n]=o[n])}return t}).apply(this,arguments)}const v=function(t,{debug:e=!1,warnOnUnknownTransitions:o=!1}={}){let n,r,i=t.initial,a=t.context;const s=[],u=(c,d)=>{const l=t.states[i],p=l.on&&l.on[c];if(void 0===p)o&&console.warn('From state: "'.concat(i,'", event "').concat(c,'" does not lead to any state'));else{n=i,r=a,l.onLeaveState&&l.onLeaveState(u);const o=t.states[p];o.onEnterState&&o.onEnterState(u),i=p,void 0!==d&&(a=d),e&&console.log({previousState:n,previousContext:r,event:c,state:i,context:a}),s.forEach((t=>t({state:i,previousState:n,context:a})))}};return{subscribe:function(t){return s.push(t),()=>{s.splice(s.indexOf(t),1)}},transition:u,getState:function(){return i},getContext:function(){return a}}}({initial:"CLOSED",context:{id:null},states:{CLOSED:{on:{mouseEntered:"WAITING_FOR_REST",focused:"OPEN"}},WAITING_FOR_REST:{onEnterState:function(t){clearTimeout(f),f=window.setTimeout((()=>t("restTimerElapsed")),200)},onLeaveState:function(){clearTimeout(f)},on:{restTimerElapsed:"OPEN",mouseMoved:"WAITING_FOR_REST",mouseLeft:"CLOSED",activated:"DISMISSED",unmounted:"CLOSED"}},OPEN:{on:{mouseLeft:"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD",mouseEntered:"OPEN",mouseMoved:"OPEN",activated:"DISMISSED",blurred:"CLOSED",triggerMoved:"CLOSED",unmounted:"CLOSED"}},CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD:{onEnterState:function(t){clearTimeout(S),S=window.setTimeout((()=>t("skipRestTimerElapsed")),200)},onLeaveState:function(){clearTimeout(S)},on:{skipRestTimerElapsed:"CLOSED",mouseEntered:"OPEN",focused:"OPEN",activated:"DISMISSED",unmounted:"CLOSED"}},DISMISSED:{on:{mouseLeft:"CLOSED",blurred:"CLOSED",unmounted:"CLOSED"}}}}),[O,g]=l("Tooltip");export const Tooltip=e=>{const{children:o,open:n,defaultOpen:r=!1,onOpenChange:i}=e,a=E.useRef(null),s=t(),[u=!1,l]=d({prop:n,defaultProp:r,onChange:i}),[p,m]=E.useState(n?"instant-open":"closed");return E.useEffect((()=>v.subscribe((({state:t,context:e})=>{"OPEN"===t&&e.id===s?l(!0):l(!1)}))),[s,l]),E.useEffect((()=>v.subscribe((({state:t,previousState:e})=>{"OPEN"===t&&("WAITING_FOR_REST"===e&&m("delayed-open"),"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD"!==e&&"CLOSED"!==e||m("instant-open")),"CLOSED"===t&&m("closed")}))),[]),E.useEffect((()=>()=>{v.transition("unmounted",{id:s})}),[s]),c((()=>{!0===n&&v.transition("mouseEntered",{id:s})}),[s,n]),E.createElement(O,{triggerRef:a,contentId:s,open:u,stateAttribute:p},o)};Tooltip.displayName="Tooltip";const I="button";export const TooltipTrigger=E.forwardRef(((t,e)=>{const{as:o=I,...n}=t,r=g("TooltipTrigger"),a=p(e,r.triggerRef);return E.createElement(i,T({type:"button","aria-describedby":r.open?r.contentId:void 0,"data-state":r.stateAttribute},n,{as:o,ref:a,onMouseEnter:m(t.onMouseEnter,(()=>v.transition("mouseEntered",{id:r.contentId}))),onMouseMove:m(t.onMouseMove,(()=>v.transition("mouseMoved",{id:r.contentId}))),onMouseLeave:m(t.onMouseLeave,(()=>{v.getContext().id===r.contentId&&v.transition("mouseLeft",{id:r.contentId})})),onFocus:m(t.onFocus,(()=>v.transition("focused",{id:r.contentId}))),onBlur:m(t.onBlur,(()=>{v.getContext().id===r.contentId&&v.transition("blurred",{id:r.contentId})})),onMouseDown:m(t.onMouseDown,(()=>v.transition("activated",{id:r.contentId}))),onKeyDown:m(t.onKeyDown,(t=>{"Escape"!==t.key&&"Enter"!==t.key&&" "!==t.key||v.transition("activated",{id:r.contentId})}))}))}));TooltipTrigger.displayName="TooltipTrigger";export const TooltipContent=E.forwardRef(((t,e)=>g("TooltipContent").open?E.createElement(x,T({ref:e},t)):null));const x=E.forwardRef(((t,i)=>{const{children:a,"aria-label":s,anchorRef:u,portalled:c=!0,...d}=t,l=g("TooltipContent"),p=c?n:E.Fragment;return E.createElement(p,null,E.createElement(C,null),E.createElement(r.Root,T({"data-state":l.stateAttribute},d,{ref:i,anchorRef:u||l.triggerRef,style:{...d.style,"--radix-tooltip-content-transform-origin":"var(--radix-popper-transform-origin)"}}),E.createElement(o,null,a),E.createElement(e.Root,{id:l.contentId,role:"tooltip"},s||a)))}));TooltipContent.displayName="TooltipContent";export const TooltipArrow=a(r.Arrow,{displayName:"TooltipArrow"});function C(){const t=g("CheckTriggerMoved"),e=s(t.triggerRef),o=null==e?void 0:e.left,n=u(o),r=null==e?void 0:e.top,i=u(r);return E.useEffect((()=>{(void 0!==n&&n!==o||void 0!==i&&i!==r)&&v.transition("triggerMoved",{id:t.contentId})}),[t.contentId,n,i,o,r]),null}export const Root=Tooltip;export const Trigger=TooltipTrigger;export const Content=TooltipContent;export const Arrow=TooltipArrow;
 //# sourceMappingURL=index.module.js.map
diff --git a/node_modules/@radix-ui/react-tooltip/dist/index.module.js.map b/node_modules/@radix-ui/react-tooltip/dist/index.module.js.map
index 2b1d365..a5ab0d4 100644
--- a/node_modules/@radix-ui/react-tooltip/dist/index.module.js.map
+++ b/node_modules/@radix-ui/react-tooltip/dist/index.module.js.map
@@ -1 +1 @@
-{"mappings":"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","sources":["./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 300;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 300;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Primitive, extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipProvider, useTooltipContext] = createContext<TooltipContextValue>(TOOLTIP_NAME);\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id: contentId });\n    };\n  }, [contentId]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <TooltipProvider\n      triggerRef={triggerRef}\n      contentId={contentId}\n      open={open}\n      stateAttribute={stateAttribute}\n    >\n      {children}\n    </TooltipProvider>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const { as = TRIGGER_DEFAULT_TAG, ...triggerProps } = props;\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      type=\"button\"\n      aria-describedby={context.open ? context.contentId : undefined}\n      data-state={context.stateAttribute}\n      {...triggerProps}\n      as={as}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.contentId })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.contentId })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('mouseLeft', { id: context.contentId });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.contentId })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('blurred', { id: context.contentId });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.contentId })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.contentId });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Polymorphic.Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        data-state={context.stateAttribute}\n        {...contentProps}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        <Slottable>{children}</Slottable>\n        <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHiddenPrimitive.Root>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'TooltipArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const context = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(context.triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolledâ€¦\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id: context.contentId });\n    }\n  }, [context.contentId, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["restTimerId","skipRestTimerId","stateMachine","stateChart","debug","warnOnUnknownTransitions","PREVIOUS_STATE","PREVIOUS_CONTEXT","CURRENT_STATE","initial","CURRENT_CONTEXT","context","subscriptions","transition","event","stateDefinition","states","nextState","on","undefined","console","warn","concat","onLeaveState","nextStateDefinition","onEnterState","log","previousState","previousContext","state","forEach","callback","subscribe","push","splice","indexOf","getState","getContext","$e37f874ef74368da320cbbbb439$export$createStateMachine","id","CLOSED","mouseEntered","focused","WAITING_FOR_REST","clearTimeout","window","setTimeout","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerElapsed","DISMISSED","TooltipProvider","useTooltipContext","createContext","Tooltip","props","children","open","openProp","defaultOpen","onOpenChange","triggerRef","React","useRef","contentId","useId","setOpen","useControllableState","prop","defaultProp","onChange","stateAttribute","setStateAttribute","useState","useEffect","useLayoutEffect","_react","createElement","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipProvider","displayName","TRIGGER_DEFAULT_TAG","TooltipTrigger","forwardRef","forwardedRef","as","triggerProps","composedTriggerRef","useComposedRefs","Primitive","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$_extends","type","aria-describedby","data-state","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","key","TooltipContent","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContentImpl","TooltipContentImpl","aria-label","ariaLabel","anchorRef","portalled","contentProps","PortalWrapper","Portal","Fragment","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$CheckTriggerMoved","_radixUiReactPopper","Root","style","--radix-tooltip-content-transform-origin","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","extendPrimitive","PopperPrimitive","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.module.js.map"}
\ No newline at end of file
+{"mappings":"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","sources":["./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 200;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 200;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Primitive, extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipProvider, useTooltipContext] = createContext<TooltipContextValue>(TOOLTIP_NAME);\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id: contentId });\n    };\n  }, [contentId]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <TooltipProvider\n      triggerRef={triggerRef}\n      contentId={contentId}\n      open={open}\n      stateAttribute={stateAttribute}\n    >\n      {children}\n    </TooltipProvider>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const { as = TRIGGER_DEFAULT_TAG, ...triggerProps } = props;\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      type=\"button\"\n      aria-describedby={context.open ? context.contentId : undefined}\n      data-state={context.stateAttribute}\n      {...triggerProps}\n      as={as}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.contentId })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.contentId })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('mouseLeft', { id: context.contentId });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.contentId })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('blurred', { id: context.contentId });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.contentId })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.contentId });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Polymorphic.Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        data-state={context.stateAttribute}\n        {...contentProps}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        <Slottable>{children}</Slottable>\n        <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHiddenPrimitive.Root>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'TooltipArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const context = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(context.triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolledâ€¦\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id: context.contentId });\n    }\n  }, [context.contentId, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["restTimerId","skipRestTimerId","stateMachine","stateChart","debug","warnOnUnknownTransitions","PREVIOUS_STATE","PREVIOUS_CONTEXT","CURRENT_STATE","initial","CURRENT_CONTEXT","context","subscriptions","transition","event","stateDefinition","states","nextState","on","undefined","console","warn","concat","onLeaveState","nextStateDefinition","onEnterState","log","previousState","previousContext","state","forEach","callback","subscribe","push","splice","indexOf","getState","getContext","$e37f874ef74368da320cbbbb439$export$createStateMachine","id","CLOSED","mouseEntered","focused","WAITING_FOR_REST","clearTimeout","window","setTimeout","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerElapsed","DISMISSED","TooltipProvider","useTooltipContext","createContext","Tooltip","props","children","open","openProp","defaultOpen","onOpenChange","triggerRef","React","useRef","contentId","useId","setOpen","useControllableState","prop","defaultProp","onChange","stateAttribute","setStateAttribute","useState","useEffect","useLayoutEffect","_react","createElement","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipProvider","displayName","TRIGGER_DEFAULT_TAG","TooltipTrigger","forwardRef","forwardedRef","as","triggerProps","composedTriggerRef","useComposedRefs","Primitive","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$_extends","type","aria-describedby","data-state","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","key","TooltipContent","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContentImpl","TooltipContentImpl","aria-label","ariaLabel","anchorRef","portalled","contentProps","PortalWrapper","Portal","Fragment","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$CheckTriggerMoved","_radixUiReactPopper","Root","style","--radix-tooltip-content-transform-origin","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","extendPrimitive","PopperPrimitive","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.module.js.map"}
