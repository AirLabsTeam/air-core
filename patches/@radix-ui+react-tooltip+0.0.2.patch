diff --git a/node_modules/@radix-ui/react-tooltip/dist/index.js b/node_modules/@radix-ui/react-tooltip/dist/index.js
index 9c89dbc..0f1821a 100644
--- a/node_modules/@radix-ui/react-tooltip/dist/index.js
+++ b/node_modules/@radix-ui/react-tooltip/dist/index.js
@@ -1,2 +1,2 @@
-var e=require("@radix-ui/react-visually-hidden").VisuallyHidden,t=require("@radix-ui/react-portal").Portal,r=O({},require("@radix-ui/react-popper")),n=require("@radix-ui/react-primitive").Primitive,o=require("@radix-ui/react-utils"),i=o.createContext,u=o.useComposedRefs,a=o.useId,c=o.composeEventHandlers,s=o.useRect,l=o.usePrevious,d=o.useControlledState,f=o.useLayoutEffect,p=o.extendComponent,v=require("@radix-ui/utils").getSelector,E=O({},require("react"));function O(e,t){return Object.keys(t).forEach((function(r){"default"!==r&&"__esModule"!==r&&Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[r]}})})),e}var S,m,b={initial:"CLOSED",context:{id:null},states:{CLOSED:{on:{mouseEntered:"WAITING_FOR_REST",focused:"OPEN"}},WAITING_FOR_REST:{onEnterState:function(e){clearTimeout(S),S=window.setTimeout((function(){return e("restTimerElapsed")}),300)},onLeaveState:function(){clearTimeout(S)},on:{restTimerElapsed:"OPEN",mouseMoved:"WAITING_FOR_REST",mouseLeft:"CLOSED",activated:"DISMISSED",unmounted:"CLOSED"}},OPEN:{on:{mouseLeft:"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD",mouseEntered:"OPEN",mouseMoved:"OPEN",activated:"DISMISSED",blurred:"CLOSED",triggerMoved:"CLOSED",unmounted:"CLOSED"}},CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD:{onEnterState:function(e){clearTimeout(m),m=window.setTimeout((function(){return e("skipRestTimerElapsed")}),300)},onLeaveState:function(){clearTimeout(m)},on:{skipRestTimerElapsed:"CLOSED",mouseEntered:"OPEN",focused:"OPEN",activated:"DISMISSED",unmounted:"CLOSED"}},DISMISSED:{on:{mouseLeft:"CLOSED",blurred:"CLOSED",unmounted:"CLOSED"}}}};function y(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function g(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?y(Object(r),!0).forEach((function(t){T(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):y(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function T(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function C(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}function D(){return(D=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}function h(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var r=[],n=!0,o=!1,i=void 0;try{for(var u,a=e[Symbol.iterator]();!(n=(u=a.next()).done)&&(r.push(u.value),!t||r.length!==t);n=!0);}catch(e){o=!0,i=e}finally{try{n||null==a.return||a.return()}finally{if(o)throw i}}return r}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return w(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);"Object"===r&&e.constructor&&(r=e.constructor.name);if("Map"===r||"Set"===r)return Array.from(e);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return w(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function w(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var x=h(i("TooltipContext","Tooltip"),2),L=x[0],R=x[1],I=function(e){var t,r,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=n.debug,i=void 0!==o&&o,u=n.warnOnUnknownTransitions,a=void 0!==u&&u,c=e.initial,s=e.context,l=[];function d(e){return l.push(e),function(){l.splice(l.indexOf(e),1)}}function f(){l.forEach((function(e){return e({state:c,previousState:t,context:s})}))}var p=function n(o,u){var l=e.states[c],d=l.on&&l.on[o];if(void 0===d)a&&console.warn('From state: "'.concat(c,'", event "').concat(o,'" does not lead to any state'));else{t=c,r=s,l.onLeaveState&&l.onLeaveState(n);var p=e.states[d];p.onEnterState&&p.onEnterState(n),c=d,void 0!==u&&(s=u),i&&console.log({previousState:t,previousContext:r,event:o,state:c,context:s}),f()}};function v(){return c}function E(){return s}return{subscribe:d,transition:p,getState:v,getContext:E}}(b),P=function(e){var t=e.children,r=e.open,n=e.defaultOpen,o=void 0!==n&&n,i=e.onOpenChange,u=E.useRef(null),c="tooltip-".concat(a()),s=h(d({prop:r,defaultProp:o,onChange:i}),2),l=s[0],p=void 0!==l&&l,v=s[1],O=h(E.useState(r?"instant-open":"closed"),2),S=O[0],m=O[1];E.useEffect((function(){return I.subscribe((function(e){var t=e.state,r=e.context;"OPEN"===t&&r.id===c?v(!0):v(!1)}))}),[c,v]),E.useEffect((function(){return I.subscribe((function(e){var t=e.state,r=e.previousState;"OPEN"===t&&("WAITING_FOR_REST"===r&&m("delayed-open"),"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD"!==r&&"CLOSED"!==r||m("instant-open")),"CLOSED"===t&&m("closed")}))}),[]),E.useEffect((function(){return function(){I.transition("unmounted",{id:c})}}),[c]),f((function(){!0===r&&I.transition("mouseEntered",{id:c})}),[c,r]);var b=E.useMemo((function(){return{triggerRef:u,id:c,open:p,stateAttribute:S}}),[c,p,S]);return E.createElement(L.Provider,{value:b},t)};exports.Tooltip=P,P.displayName="Tooltip";var _=E.forwardRef((function(e,t){var r=R("TooltipTrigger"),o=u(t,r.triggerRef);return E.createElement(n,D({as:"button",selector:v("TooltipTrigger"),type:"button","aria-describedby":r.open?r.id:void 0},e,{ref:o,onMouseEnter:c(e.onMouseEnter,(function(){return I.transition("mouseEntered",{id:r.id})})),onMouseMove:c(e.onMouseMove,(function(){return I.transition("mouseMoved",{id:r.id})})),onMouseLeave:c(e.onMouseLeave,(function(){I.getContext().id===r.id&&I.transition("mouseLeft",{id:r.id})})),onFocus:c(e.onFocus,(function(){return I.transition("focused",{id:r.id})})),onBlur:c(e.onBlur,(function(){I.getContext().id===r.id&&I.transition("blurred",{id:r.id})})),onMouseDown:c(e.onMouseDown,(function(){return I.transition("activated",{id:r.id})})),onKeyDown:c(e.onKeyDown,(function(e){"Escape"!==e.key&&"Enter"!==e.key&&" "!==e.key||I.transition("activated",{id:r.id})}))}))}));exports.TooltipTrigger=_,_.displayName="TooltipTrigger";var j=E.forwardRef((function(e,t){return R("TooltipContent").open?E.createElement(M,D({ref:t},e)):null}));exports.TooltipContent=j;var M=E.forwardRef((function(n,o){var i=n.children,u=n["aria-label"],a=n.anchorRef,c=n.portalled,s=void 0===c||c,l=C(n,["children","aria-label","anchorRef","portalled"]),d=R("TooltipContent"),f=s?t:E.Fragment;return E.createElement(f,null,E.createElement(A,null),E.createElement(r.Root,D({selector:v("TooltipContent")},l,{"data-state":d.stateAttribute,ref:o,anchorRef:a||d.triggerRef,style:g(g({},l.style),{},T({},"--radix-tooltip-content-transform-origin","var(--radix-popper-transform-origin)"))}),i,E.createElement(e,{id:d.id,role:"tooltip"},u||i)))}));j.displayName="TooltipContent";var N=p(r.Arrow,"TooltipArrow");function A(){var e=R("CheckTriggerMoved"),t=e.triggerRef,r=e.id,n=s(t),o=null==n?void 0:n.left,i=l(o),u=null==n?void 0:n.top,a=l(u);return E.useEffect((function(){(void 0!==i&&i!==o||void 0!==a&&a!==u)&&I.transition("triggerMoved",{id:r})}),[r,i,a,o,u]),null}exports.TooltipArrow=N;var H=P;exports.Root=H;var F=_;exports.Trigger=F;var k=j;exports.Content=k;var K=N;exports.Arrow=K;
+var e=require("@radix-ui/react-visually-hidden").VisuallyHidden,t=require("@radix-ui/react-portal").Portal,r=O({},require("@radix-ui/react-popper")),n=require("@radix-ui/react-primitive").Primitive,o=require("@radix-ui/react-utils"),i=o.createContext,u=o.useComposedRefs,a=o.useId,c=o.composeEventHandlers,s=o.useRect,l=o.usePrevious,d=o.useControlledState,f=o.useLayoutEffect,p=o.extendComponent,v=require("@radix-ui/utils").getSelector,E=O({},require("react"));function O(e,t){return Object.keys(t).forEach((function(r){"default"!==r&&"__esModule"!==r&&Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[r]}})})),e}var S,m,b={initial:"CLOSED",context:{id:null},states:{CLOSED:{on:{mouseEntered:"WAITING_FOR_REST",focused:"OPEN"}},WAITING_FOR_REST:{onEnterState:function(e){clearTimeout(S),S=window.setTimeout((function(){return e("restTimerElapsed")}),200)},onLeaveState:function(){clearTimeout(S)},on:{restTimerElapsed:"OPEN",mouseMoved:"WAITING_FOR_REST",mouseLeft:"CLOSED",activated:"DISMISSED",unmounted:"CLOSED"}},OPEN:{on:{mouseLeft:"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD",mouseEntered:"OPEN",mouseMoved:"OPEN",activated:"DISMISSED",blurred:"CLOSED",triggerMoved:"CLOSED",unmounted:"CLOSED"}},CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD:{onEnterState:function(e){clearTimeout(m),m=window.setTimeout((function(){return e("skipRestTimerElapsed")}),200)},onLeaveState:function(){clearTimeout(m)},on:{skipRestTimerElapsed:"CLOSED",mouseEntered:"OPEN",focused:"OPEN",activated:"DISMISSED",unmounted:"CLOSED"}},DISMISSED:{on:{mouseLeft:"CLOSED",blurred:"CLOSED",unmounted:"CLOSED"}}}};function y(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function g(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?y(Object(r),!0).forEach((function(t){T(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):y(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function T(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function C(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}function D(){return(D=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}function h(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var r=[],n=!0,o=!1,i=void 0;try{for(var u,a=e[Symbol.iterator]();!(n=(u=a.next()).done)&&(r.push(u.value),!t||r.length!==t);n=!0);}catch(e){o=!0,i=e}finally{try{n||null==a.return||a.return()}finally{if(o)throw i}}return r}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return w(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);"Object"===r&&e.constructor&&(r=e.constructor.name);if("Map"===r||"Set"===r)return Array.from(e);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return w(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function w(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var x=h(i("TooltipContext","Tooltip"),2),L=x[0],R=x[1],I=function(e){var t,r,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=n.debug,i=void 0!==o&&o,u=n.warnOnUnknownTransitions,a=void 0!==u&&u,c=e.initial,s=e.context,l=[];function d(e){return l.push(e),function(){l.splice(l.indexOf(e),1)}}function f(){l.forEach((function(e){return e({state:c,previousState:t,context:s})}))}var p=function n(o,u){var l=e.states[c],d=l.on&&l.on[o];if(void 0===d)a&&console.warn('From state: "'.concat(c,'", event "').concat(o,'" does not lead to any state'));else{t=c,r=s,l.onLeaveState&&l.onLeaveState(n);var p=e.states[d];p.onEnterState&&p.onEnterState(n),c=d,void 0!==u&&(s=u),i&&console.log({previousState:t,previousContext:r,event:o,state:c,context:s}),f()}};function v(){return c}function E(){return s}return{subscribe:d,transition:p,getState:v,getContext:E}}(b),P=function(e){var t=e.children,r=e.open,n=e.defaultOpen,o=void 0!==n&&n,i=e.onOpenChange,u=E.useRef(null),c="tooltip-".concat(a()),s=h(d({prop:r,defaultProp:o,onChange:i}),2),l=s[0],p=void 0!==l&&l,v=s[1],O=h(E.useState(r?"instant-open":"closed"),2),S=O[0],m=O[1];E.useEffect((function(){return I.subscribe((function(e){var t=e.state,r=e.context;"OPEN"===t&&r.id===c?v(!0):v(!1)}))}),[c,v]),E.useEffect((function(){return I.subscribe((function(e){var t=e.state,r=e.previousState;"OPEN"===t&&("WAITING_FOR_REST"===r&&m("delayed-open"),"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD"!==r&&"CLOSED"!==r||m("instant-open")),"CLOSED"===t&&m("closed")}))}),[]),E.useEffect((function(){return function(){I.transition("unmounted",{id:c})}}),[c]),f((function(){!0===r&&I.transition("mouseEntered",{id:c})}),[c,r]);var b=E.useMemo((function(){return{triggerRef:u,id:c,open:p,stateAttribute:S}}),[c,p,S]);return E.createElement(L.Provider,{value:b},t)};exports.Tooltip=P,P.displayName="Tooltip";var _=E.forwardRef((function(e,t){var r=R("TooltipTrigger"),o=u(t,r.triggerRef);return E.createElement(n,D({as:"button",selector:v("TooltipTrigger"),type:"button","aria-describedby":r.open?r.id:void 0},e,{ref:o,onMouseEnter:c(e.onMouseEnter,(function(){return I.transition("mouseEntered",{id:r.id})})),onMouseMove:c(e.onMouseMove,(function(){return I.transition("mouseMoved",{id:r.id})})),onMouseLeave:c(e.onMouseLeave,(function(){I.getContext().id===r.id&&I.transition("mouseLeft",{id:r.id})})),onFocus:c(e.onFocus,(function(){return I.transition("focused",{id:r.id})})),onBlur:c(e.onBlur,(function(){I.getContext().id===r.id&&I.transition("blurred",{id:r.id})})),onMouseDown:c(e.onMouseDown,(function(){return I.transition("activated",{id:r.id})})),onKeyDown:c(e.onKeyDown,(function(e){"Escape"!==e.key&&"Enter"!==e.key&&" "!==e.key||I.transition("activated",{id:r.id})}))}))}));exports.TooltipTrigger=_,_.displayName="TooltipTrigger";var j=E.forwardRef((function(e,t){return R("TooltipContent").open?E.createElement(M,D({ref:t},e)):null}));exports.TooltipContent=j;var M=E.forwardRef((function(n,o){var i=n.children,u=n["aria-label"],a=n.anchorRef,c=n.portalled,s=void 0===c||c,l=C(n,["children","aria-label","anchorRef","portalled"]),d=R("TooltipContent"),f=s?t:E.Fragment;return E.createElement(f,null,E.createElement(A,null),E.createElement(r.Root,D({selector:v("TooltipContent")},l,{"data-state":d.stateAttribute,ref:o,anchorRef:a||d.triggerRef,style:g(g({},l.style),{},T({},"--radix-tooltip-content-transform-origin","var(--radix-popper-transform-origin)"))}),i,E.createElement(e,{id:d.id,role:"tooltip"},u||i)))}));j.displayName="TooltipContent";var N=p(r.Arrow,"TooltipArrow");function A(){var e=R("CheckTriggerMoved"),t=e.triggerRef,r=e.id,n=s(t),o=null==n?void 0:n.left,i=l(o),u=null==n?void 0:n.top,a=l(u);return E.useEffect((function(){(void 0!==i&&i!==o||void 0!==a&&a!==u)&&I.transition("triggerMoved",{id:r})}),[r,i,a,o,u]),null}exports.TooltipArrow=N;var H=P;exports.Root=H;var F=_;exports.Trigger=F;var k=j;exports.Content=k;var K=N;exports.Arrow=K;
 //# sourceMappingURL=index.js.map
diff --git a/node_modules/@radix-ui/react-tooltip/dist/index.js.map b/node_modules/@radix-ui/react-tooltip/dist/index.js.map
index fc10b6d..b75f807 100644
--- a/node_modules/@radix-ui/react-tooltip/dist/index.js.map
+++ b/node_modules/@radix-ui/react-tooltip/dist/index.js.map
@@ -1 +1 @@
-{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 300;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 300;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { getSelector } from '@radix-ui/utils';\nimport {\n  createContext,\n  useComposedRefs,\n  useId,\n  composeEventHandlers,\n  useRect,\n  usePrevious,\n  useControlledState,\n  useLayoutEffect,\n  extendComponent,\n} from '@radix-ui/react-utils';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\nimport type { Merge } from '@radix-ui/utils';\n\n/* -------------------------------------------------------------------------------------------------\n * Root level context\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  id: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipContext, useTooltipContext] = createContext<TooltipContextValue>(\n  'TooltipContext',\n  'Tooltip'\n);\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const id = `tooltip-${useId()}`;\n  const [open = false, setOpen] = useControlledState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === id) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [id, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id });\n    };\n  }, [id]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id });\n    }\n  }, [id, openProp]);\n\n  const context = React.useMemo(() => ({ triggerRef, id, open, stateAttribute }), [\n    id,\n    open,\n    stateAttribute,\n  ]);\n\n  return <TooltipContext.Provider value={context}>{children}</TooltipContext.Provider>;\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      as={TRIGGER_DEFAULT_TAG}\n      selector={getSelector(TRIGGER_NAME)}\n      type=\"button\"\n      aria-describedby={context.open ? context.id : undefined}\n      {...props}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.id })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.id })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.id) {\n          stateMachine.transition('mouseLeft', { id: context.id });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.id })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.id) {\n          stateMachine.transition('blurred', { id: context.id });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.id })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.id });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        selector={getSelector(CONTENT_NAME)}\n        {...contentProps}\n        data-state={context.stateAttribute}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        {children}\n        <VisuallyHidden id={context.id} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHidden>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendComponent(PopperPrimitive.Arrow, 'TooltipArrow');\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const { triggerRef, id } = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id });\n    }\n  }, [id, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["$parcel$exportWildcard","dest","source","Object","keys","forEach","key","defineProperty","enumerable","get","restTimerId","skipRestTimerId","stateChart","initial","context","id","states","CLOSED","on","mouseEntered","focused","WAITING_FOR_REST","onEnterState","transition","clearTimeout","window","setTimeout","onLeaveState","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerElapsed","DISMISSED","createContext","TooltipContext","useTooltipContext","stateMachine","PREVIOUS_STATE","PREVIOUS_CONTEXT","_ref","arguments","length","undefined","_ref$debug","debug","_ref$warnOnUnknownTra","warnOnUnknownTransitions","CURRENT_STATE","CURRENT_CONTEXT","subscriptions","subscribe","callback","push","splice","indexOf","notify","state","previousState","event","stateDefinition","nextState","console","warn","concat","nextStateDefinition","log","previousContext","getState","getContext","$e635218480c28d9f27af72d31e573b83$export$createStateMachine","$e635218480c28d9f27af72d31e573b83$export$stateChart","Tooltip","props","children","openProp","open","_props$defaultOpen","defaultOpen","onOpenChange","triggerRef","React","useRef","useId","_useControlledState2","$bfd2ef98f93cfd0786881e49eeb6a4$var$_slicedToArray","useControlledState","prop","defaultProp","onChange","_useControlledState2$","setOpen","_React$useState2","useState","stateAttribute","setStateAttribute","useEffect","_ref2","useLayoutEffect","useMemo","_react","createElement","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipContext","Provider","value","displayName","TooltipTrigger","forwardRef","forwardedRef","composedTriggerRef","useComposedRefs","Primitive","$bfd2ef98f93cfd0786881e49eeb6a4$var$_extends","as","selector","getSelector","type","aria-describedby","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","TooltipContent","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipContentImpl","TooltipContentImpl","ariaLabel","anchorRef","_props$portalled","portalled","contentProps","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectWithoutProperties","PortalWrapper","Portal","Fragment","$bfd2ef98f93cfd0786881e49eeb6a4$var$CheckTriggerMoved","_radixUiReactPopper","Root","data-state","style","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectSpread","$bfd2ef98f93cfd0786881e49eeb6a4$var$_defineProperty","VisuallyHidden","role","TooltipArrow","extendComponent","PopperPrimitive","Arrow","CheckTriggerMoved","_useTooltipContext","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.js.map"}
\ No newline at end of file
+{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 200;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 200;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { getSelector } from '@radix-ui/utils';\nimport {\n  createContext,\n  useComposedRefs,\n  useId,\n  composeEventHandlers,\n  useRect,\n  usePrevious,\n  useControlledState,\n  useLayoutEffect,\n  extendComponent,\n} from '@radix-ui/react-utils';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\nimport type { Merge } from '@radix-ui/utils';\n\n/* -------------------------------------------------------------------------------------------------\n * Root level context\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  id: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipContext, useTooltipContext] = createContext<TooltipContextValue>(\n  'TooltipContext',\n  'Tooltip'\n);\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const id = `tooltip-${useId()}`;\n  const [open = false, setOpen] = useControlledState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === id) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [id, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id });\n    };\n  }, [id]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id });\n    }\n  }, [id, openProp]);\n\n  const context = React.useMemo(() => ({ triggerRef, id, open, stateAttribute }), [\n    id,\n    open,\n    stateAttribute,\n  ]);\n\n  return <TooltipContext.Provider value={context}>{children}</TooltipContext.Provider>;\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      as={TRIGGER_DEFAULT_TAG}\n      selector={getSelector(TRIGGER_NAME)}\n      type=\"button\"\n      aria-describedby={context.open ? context.id : undefined}\n      {...props}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.id })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.id })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.id) {\n          stateMachine.transition('mouseLeft', { id: context.id });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.id })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.id) {\n          stateMachine.transition('blurred', { id: context.id });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.id })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.id });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        selector={getSelector(CONTENT_NAME)}\n        {...contentProps}\n        data-state={context.stateAttribute}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        {children}\n        <VisuallyHidden id={context.id} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHidden>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendComponent(PopperPrimitive.Arrow, 'TooltipArrow');\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const { triggerRef, id } = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id });\n    }\n  }, [id, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["$parcel$exportWildcard","dest","source","Object","keys","forEach","key","defineProperty","enumerable","get","restTimerId","skipRestTimerId","stateChart","initial","context","id","states","CLOSED","on","mouseEntered","focused","WAITING_FOR_REST","onEnterState","transition","clearTimeout","window","setTimeout","onLeaveState","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerElapsed","DISMISSED","createContext","TooltipContext","useTooltipContext","stateMachine","PREVIOUS_STATE","PREVIOUS_CONTEXT","_ref","arguments","length","undefined","_ref$debug","debug","_ref$warnOnUnknownTra","warnOnUnknownTransitions","CURRENT_STATE","CURRENT_CONTEXT","subscriptions","subscribe","callback","push","splice","indexOf","notify","state","previousState","event","stateDefinition","nextState","console","warn","concat","nextStateDefinition","log","previousContext","getState","getContext","$e635218480c28d9f27af72d31e573b83$export$createStateMachine","$e635218480c28d9f27af72d31e573b83$export$stateChart","Tooltip","props","children","openProp","open","_props$defaultOpen","defaultOpen","onOpenChange","triggerRef","React","useRef","useId","_useControlledState2","$bfd2ef98f93cfd0786881e49eeb6a4$var$_slicedToArray","useControlledState","prop","defaultProp","onChange","_useControlledState2$","setOpen","_React$useState2","useState","stateAttribute","setStateAttribute","useEffect","_ref2","useLayoutEffect","useMemo","_react","createElement","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipContext","Provider","value","displayName","TooltipTrigger","forwardRef","forwardedRef","composedTriggerRef","useComposedRefs","Primitive","$bfd2ef98f93cfd0786881e49eeb6a4$var$_extends","as","selector","getSelector","type","aria-describedby","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","TooltipContent","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipContentImpl","TooltipContentImpl","ariaLabel","anchorRef","_props$portalled","portalled","contentProps","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectWithoutProperties","PortalWrapper","Portal","Fragment","$bfd2ef98f93cfd0786881e49eeb6a4$var$CheckTriggerMoved","_radixUiReactPopper","Root","data-state","style","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectSpread","$bfd2ef98f93cfd0786881e49eeb6a4$var$_defineProperty","VisuallyHidden","role","TooltipArrow","extendComponent","PopperPrimitive","Arrow","CheckTriggerMoved","_useTooltipContext","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.js.map"}
diff --git a/node_modules/@radix-ui/react-tooltip/dist/index.module.js b/node_modules/@radix-ui/react-tooltip/dist/index.module.js
index 715cb28..0708bdd 100644
--- a/node_modules/@radix-ui/react-tooltip/dist/index.module.js
+++ b/node_modules/@radix-ui/react-tooltip/dist/index.module.js
@@ -1,2 +1,2 @@
-import{VisuallyHidden as e}from"@radix-ui/react-visually-hidden";import{Portal as t}from"@radix-ui/react-portal";import*as o from"@radix-ui/react-popper";import{Primitive as n}from"@radix-ui/react-primitive";import{createContext as r,useComposedRefs as i,useId as a,composeEventHandlers as s,useRect as u,usePrevious as l,useControlledState as c,useLayoutEffect as d,extendComponent as p}from"@radix-ui/react-utils";import{getSelector as f}from"@radix-ui/utils";import*as E from"react";const O={initial:"CLOSED",context:{id:null},states:{CLOSED:{on:{mouseEntered:"WAITING_FOR_REST",focused:"OPEN"}},WAITING_FOR_REST:{onEnterState:function(e){clearTimeout(m),m=window.setTimeout((()=>e("restTimerElapsed")),300)},onLeaveState:function(){clearTimeout(m)},on:{restTimerElapsed:"OPEN",mouseMoved:"WAITING_FOR_REST",mouseLeft:"CLOSED",activated:"DISMISSED",unmounted:"CLOSED"}},OPEN:{on:{mouseLeft:"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD",mouseEntered:"OPEN",mouseMoved:"OPEN",activated:"DISMISSED",blurred:"CLOSED",triggerMoved:"CLOSED",unmounted:"CLOSED"}},CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD:{onEnterState:function(e){clearTimeout(S),S=window.setTimeout((()=>e("skipRestTimerElapsed")),300)},onLeaveState:function(){clearTimeout(S)},on:{skipRestTimerElapsed:"CLOSED",mouseEntered:"OPEN",focused:"OPEN",activated:"DISMISSED",unmounted:"CLOSED"}},DISMISSED:{on:{mouseLeft:"CLOSED",blurred:"CLOSED",unmounted:"CLOSED"}}}};let m,S;function T(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function g(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?T(Object(o),!0).forEach((function(t){v(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):T(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function v(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function b(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}function y(){return(y=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e}).apply(this,arguments)}const[C,D]=r("TooltipContext","Tooltip"),L=function(e,{debug:t=!1,warnOnUnknownTransitions:o=!1}={}){let n,r,i=e.initial,a=e.context;const s=[],u=(l,c)=>{const d=e.states[i],p=d.on&&d.on[l];if(void 0===p)o&&console.warn('From state: "'.concat(i,'", event "').concat(l,'" does not lead to any state'));else{n=i,r=a,d.onLeaveState&&d.onLeaveState(u);const o=e.states[p];o.onEnterState&&o.onEnterState(u),i=p,void 0!==c&&(a=c),t&&console.log({previousState:n,previousContext:r,event:l,state:i,context:a}),s.forEach((e=>e({state:i,previousState:n,context:a})))}};return{subscribe:function(e){return s.push(e),()=>{s.splice(s.indexOf(e),1)}},transition:u,getState:function(){return i},getContext:function(){return a}}}(O);export const Tooltip=e=>{const{children:t,open:o,defaultOpen:n=!1,onOpenChange:r}=e,i=E.useRef(null),s="tooltip-".concat(a()),[u=!1,l]=c({prop:o,defaultProp:n,onChange:r}),[p,f]=E.useState(o?"instant-open":"closed");E.useEffect((()=>L.subscribe((({state:e,context:t})=>{"OPEN"===e&&t.id===s?l(!0):l(!1)}))),[s,l]),E.useEffect((()=>L.subscribe((({state:e,previousState:t})=>{"OPEN"===e&&("WAITING_FOR_REST"===t&&f("delayed-open"),"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD"!==t&&"CLOSED"!==t||f("instant-open")),"CLOSED"===e&&f("closed")}))),[]),E.useEffect((()=>()=>{L.transition("unmounted",{id:s})}),[s]),d((()=>{!0===o&&L.transition("mouseEntered",{id:s})}),[s,o]);const O=E.useMemo((()=>({triggerRef:i,id:s,open:u,stateAttribute:p})),[s,u,p]);return E.createElement(C.Provider,{value:O},t)};Tooltip.displayName="Tooltip";export const TooltipTrigger=E.forwardRef(((e,t)=>{const o=D("TooltipTrigger"),r=i(t,o.triggerRef);return E.createElement(n,y({as:"button",selector:f("TooltipTrigger"),type:"button","aria-describedby":o.open?o.id:void 0},e,{ref:r,onMouseEnter:s(e.onMouseEnter,(()=>L.transition("mouseEntered",{id:o.id}))),onMouseMove:s(e.onMouseMove,(()=>L.transition("mouseMoved",{id:o.id}))),onMouseLeave:s(e.onMouseLeave,(()=>{L.getContext().id===o.id&&L.transition("mouseLeft",{id:o.id})})),onFocus:s(e.onFocus,(()=>L.transition("focused",{id:o.id}))),onBlur:s(e.onBlur,(()=>{L.getContext().id===o.id&&L.transition("blurred",{id:o.id})})),onMouseDown:s(e.onMouseDown,(()=>L.transition("activated",{id:o.id}))),onKeyDown:s(e.onKeyDown,(e=>{"Escape"!==e.key&&"Enter"!==e.key&&" "!==e.key||L.transition("activated",{id:o.id})}))}))}));TooltipTrigger.displayName="TooltipTrigger";export const TooltipContent=E.forwardRef(((e,t)=>D("TooltipContent").open?E.createElement(w,y({ref:t},e)):null));const w=E.forwardRef(((n,r)=>{const{children:i,"aria-label":a,anchorRef:s,portalled:u=!0}=n,l=b(n,["children","aria-label","anchorRef","portalled"]),c=D("TooltipContent"),d=u?t:E.Fragment;return E.createElement(d,null,E.createElement(x,null),E.createElement(o.Root,y({selector:f("TooltipContent")},l,{"data-state":c.stateAttribute,ref:r,anchorRef:s||c.triggerRef,style:g(g({},l.style),{},{"--radix-tooltip-content-transform-origin":"var(--radix-popper-transform-origin)"})}),i,E.createElement(e,{id:c.id,role:"tooltip"},a||i)))}));TooltipContent.displayName="TooltipContent";export const TooltipArrow=p(o.Arrow,"TooltipArrow");function x(){const{triggerRef:e,id:t}=D("CheckTriggerMoved"),o=u(e),n=null==o?void 0:o.left,r=l(n),i=null==o?void 0:o.top,a=l(i);return E.useEffect((()=>{(void 0!==r&&r!==n||void 0!==a&&a!==i)&&L.transition("triggerMoved",{id:t})}),[t,r,a,n,i]),null}export const Root=Tooltip;export const Trigger=TooltipTrigger;export const Content=TooltipContent;export const Arrow=TooltipArrow;
+import{VisuallyHidden as e}from"@radix-ui/react-visually-hidden";import{Portal as t}from"@radix-ui/react-portal";import*as o from"@radix-ui/react-popper";import{Primitive as n}from"@radix-ui/react-primitive";import{createContext as r,useComposedRefs as i,useId as a,composeEventHandlers as s,useRect as u,usePrevious as l,useControlledState as c,useLayoutEffect as d,extendComponent as p}from"@radix-ui/react-utils";import{getSelector as f}from"@radix-ui/utils";import*as E from"react";const O={initial:"CLOSED",context:{id:null},states:{CLOSED:{on:{mouseEntered:"WAITING_FOR_REST",focused:"OPEN"}},WAITING_FOR_REST:{onEnterState:function(e){clearTimeout(m),m=window.setTimeout((()=>e("restTimerElapsed")),200)},onLeaveState:function(){clearTimeout(m)},on:{restTimerElapsed:"OPEN",mouseMoved:"WAITING_FOR_REST",mouseLeft:"CLOSED",activated:"DISMISSED",unmounted:"CLOSED"}},OPEN:{on:{mouseLeft:"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD",mouseEntered:"OPEN",mouseMoved:"OPEN",activated:"DISMISSED",blurred:"CLOSED",triggerMoved:"CLOSED",unmounted:"CLOSED"}},CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD:{onEnterState:function(e){clearTimeout(S),S=window.setTimeout((()=>e("skipRestTimerElapsed")),200)},onLeaveState:function(){clearTimeout(S)},on:{skipRestTimerElapsed:"CLOSED",mouseEntered:"OPEN",focused:"OPEN",activated:"DISMISSED",unmounted:"CLOSED"}},DISMISSED:{on:{mouseLeft:"CLOSED",blurred:"CLOSED",unmounted:"CLOSED"}}}};let m,S;function T(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function g(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?T(Object(o),!0).forEach((function(t){v(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):T(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function v(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function b(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}function y(){return(y=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e}).apply(this,arguments)}const[C,D]=r("TooltipContext","Tooltip"),L=function(e,{debug:t=!1,warnOnUnknownTransitions:o=!1}={}){let n,r,i=e.initial,a=e.context;const s=[],u=(l,c)=>{const d=e.states[i],p=d.on&&d.on[l];if(void 0===p)o&&console.warn('From state: "'.concat(i,'", event "').concat(l,'" does not lead to any state'));else{n=i,r=a,d.onLeaveState&&d.onLeaveState(u);const o=e.states[p];o.onEnterState&&o.onEnterState(u),i=p,void 0!==c&&(a=c),t&&console.log({previousState:n,previousContext:r,event:l,state:i,context:a}),s.forEach((e=>e({state:i,previousState:n,context:a})))}};return{subscribe:function(e){return s.push(e),()=>{s.splice(s.indexOf(e),1)}},transition:u,getState:function(){return i},getContext:function(){return a}}}(O);export const Tooltip=e=>{const{children:t,open:o,defaultOpen:n=!1,onOpenChange:r}=e,i=E.useRef(null),s="tooltip-".concat(a()),[u=!1,l]=c({prop:o,defaultProp:n,onChange:r}),[p,f]=E.useState(o?"instant-open":"closed");E.useEffect((()=>L.subscribe((({state:e,context:t})=>{"OPEN"===e&&t.id===s?l(!0):l(!1)}))),[s,l]),E.useEffect((()=>L.subscribe((({state:e,previousState:t})=>{"OPEN"===e&&("WAITING_FOR_REST"===t&&f("delayed-open"),"CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD"!==t&&"CLOSED"!==t||f("instant-open")),"CLOSED"===e&&f("closed")}))),[]),E.useEffect((()=>()=>{L.transition("unmounted",{id:s})}),[s]),d((()=>{!0===o&&L.transition("mouseEntered",{id:s})}),[s,o]);const O=E.useMemo((()=>({triggerRef:i,id:s,open:u,stateAttribute:p})),[s,u,p]);return E.createElement(C.Provider,{value:O},t)};Tooltip.displayName="Tooltip";export const TooltipTrigger=E.forwardRef(((e,t)=>{const o=D("TooltipTrigger"),r=i(t,o.triggerRef);return E.createElement(n,y({as:"button",selector:f("TooltipTrigger"),type:"button","aria-describedby":o.open?o.id:void 0},e,{ref:r,onMouseEnter:s(e.onMouseEnter,(()=>L.transition("mouseEntered",{id:o.id}))),onMouseMove:s(e.onMouseMove,(()=>L.transition("mouseMoved",{id:o.id}))),onMouseLeave:s(e.onMouseLeave,(()=>{L.getContext().id===o.id&&L.transition("mouseLeft",{id:o.id})})),onFocus:s(e.onFocus,(()=>L.transition("focused",{id:o.id}))),onBlur:s(e.onBlur,(()=>{L.getContext().id===o.id&&L.transition("blurred",{id:o.id})})),onMouseDown:s(e.onMouseDown,(()=>L.transition("activated",{id:o.id}))),onKeyDown:s(e.onKeyDown,(e=>{"Escape"!==e.key&&"Enter"!==e.key&&" "!==e.key||L.transition("activated",{id:o.id})}))}))}));TooltipTrigger.displayName="TooltipTrigger";export const TooltipContent=E.forwardRef(((e,t)=>D("TooltipContent").open?E.createElement(w,y({ref:t},e)):null));const w=E.forwardRef(((n,r)=>{const{children:i,"aria-label":a,anchorRef:s,portalled:u=!0}=n,l=b(n,["children","aria-label","anchorRef","portalled"]),c=D("TooltipContent"),d=u?t:E.Fragment;return E.createElement(d,null,E.createElement(x,null),E.createElement(o.Root,y({selector:f("TooltipContent")},l,{"data-state":c.stateAttribute,ref:r,anchorRef:s||c.triggerRef,style:g(g({},l.style),{},{"--radix-tooltip-content-transform-origin":"var(--radix-popper-transform-origin)"})}),i,E.createElement(e,{id:c.id,role:"tooltip"},a||i)))}));TooltipContent.displayName="TooltipContent";export const TooltipArrow=p(o.Arrow,"TooltipArrow");function x(){const{triggerRef:e,id:t}=D("CheckTriggerMoved"),o=u(e),n=null==o?void 0:o.left,r=l(n),i=null==o?void 0:o.top,a=l(i);return E.useEffect((()=>{(void 0!==r&&r!==n||void 0!==a&&a!==i)&&L.transition("triggerMoved",{id:t})}),[t,r,a,n,i]),null}export const Root=Tooltip;export const Trigger=TooltipTrigger;export const Content=TooltipContent;export const Arrow=TooltipArrow;
 //# sourceMappingURL=index.module.js.map
diff --git a/node_modules/@radix-ui/react-tooltip/dist/index.module.js.map b/node_modules/@radix-ui/react-tooltip/dist/index.module.js.map
index 831ecb8..9513b1f 100644
--- a/node_modules/@radix-ui/react-tooltip/dist/index.module.js.map
+++ b/node_modules/@radix-ui/react-tooltip/dist/index.module.js.map
@@ -1 +1 @@
-{"mappings":"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","sources":["./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 300;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 300;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { getSelector } from '@radix-ui/utils';\nimport {\n  createContext,\n  useComposedRefs,\n  useId,\n  composeEventHandlers,\n  useRect,\n  usePrevious,\n  useControlledState,\n  useLayoutEffect,\n  extendComponent,\n} from '@radix-ui/react-utils';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\nimport type { Merge } from '@radix-ui/utils';\n\n/* -------------------------------------------------------------------------------------------------\n * Root level context\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  id: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipContext, useTooltipContext] = createContext<TooltipContextValue>(\n  'TooltipContext',\n  'Tooltip'\n);\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const id = `tooltip-${useId()}`;\n  const [open = false, setOpen] = useControlledState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === id) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [id, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id });\n    };\n  }, [id]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id });\n    }\n  }, [id, openProp]);\n\n  const context = React.useMemo(() => ({ triggerRef, id, open, stateAttribute }), [\n    id,\n    open,\n    stateAttribute,\n  ]);\n\n  return <TooltipContext.Provider value={context}>{children}</TooltipContext.Provider>;\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      as={TRIGGER_DEFAULT_TAG}\n      selector={getSelector(TRIGGER_NAME)}\n      type=\"button\"\n      aria-describedby={context.open ? context.id : undefined}\n      {...props}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.id })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.id })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.id) {\n          stateMachine.transition('mouseLeft', { id: context.id });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.id })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.id) {\n          stateMachine.transition('blurred', { id: context.id });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.id })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.id });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        selector={getSelector(CONTENT_NAME)}\n        {...contentProps}\n        data-state={context.stateAttribute}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        {children}\n        <VisuallyHidden id={context.id} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHidden>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendComponent(PopperPrimitive.Arrow, 'TooltipArrow');\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const { triggerRef, id } = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id });\n    }\n  }, [id, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["stateChart","initial","context","id","states","CLOSED","on","mouseEntered","focused","WAITING_FOR_REST","onEnterState","transition","clearTimeout","restTimerId","window","setTimeout","onLeaveState","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerId","skipRestTimerElapsed","DISMISSED","TooltipContext","useTooltipContext","createContext","stateMachine","debug","warnOnUnknownTransitions","PREVIOUS_STATE","PREVIOUS_CONTEXT","CURRENT_STATE","CURRENT_CONTEXT","subscriptions","event","stateDefinition","nextState","undefined","console","warn","concat","nextStateDefinition","log","previousState","previousContext","state","forEach","callback","subscribe","push","splice","indexOf","getState","getContext","$e37f874ef74368da320cbbbb439$export$createStateMachine","$e37f874ef74368da320cbbbb439$export$stateChart","Tooltip","props","children","open","openProp","defaultOpen","onOpenChange","triggerRef","React","useRef","useId","setOpen","useControlledState","prop","defaultProp","onChange","stateAttribute","setStateAttribute","useState","useEffect","useLayoutEffect","useMemo","_react","createElement","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContext","Provider","value","displayName","TooltipTrigger","forwardRef","forwardedRef","composedTriggerRef","useComposedRefs","Primitive","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$_extends","as","selector","getSelector","type","aria-describedby","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","key","TooltipContent","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContentImpl","TooltipContentImpl","aria-label","ariaLabel","anchorRef","portalled","contentProps","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$_objectWithoutProperties","PortalWrapper","Portal","Fragment","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$CheckTriggerMoved","_radixUiReactPopper","Root","data-state","style","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$_objectSpread","--radix-tooltip-content-transform-origin","VisuallyHidden","role","TooltipArrow","extendComponent","PopperPrimitive","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.module.js.map"}
\ No newline at end of file
+{"mappings":"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","sources":["./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 200;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 200;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { getSelector } from '@radix-ui/utils';\nimport {\n  createContext,\n  useComposedRefs,\n  useId,\n  composeEventHandlers,\n  useRect,\n  usePrevious,\n  useControlledState,\n  useLayoutEffect,\n  extendComponent,\n} from '@radix-ui/react-utils';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\nimport type { Merge } from '@radix-ui/utils';\n\n/* -------------------------------------------------------------------------------------------------\n * Root level context\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  id: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipContext, useTooltipContext] = createContext<TooltipContextValue>(\n  'TooltipContext',\n  'Tooltip'\n);\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const id = `tooltip-${useId()}`;\n  const [open = false, setOpen] = useControlledState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === id) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [id, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id });\n    };\n  }, [id]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id });\n    }\n  }, [id, openProp]);\n\n  const context = React.useMemo(() => ({ triggerRef, id, open, stateAttribute }), [\n    id,\n    open,\n    stateAttribute,\n  ]);\n\n  return <TooltipContext.Provider value={context}>{children}</TooltipContext.Provider>;\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      as={TRIGGER_DEFAULT_TAG}\n      selector={getSelector(TRIGGER_NAME)}\n      type=\"button\"\n      aria-describedby={context.open ? context.id : undefined}\n      {...props}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.id })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.id })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.id) {\n          stateMachine.transition('mouseLeft', { id: context.id });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.id })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.id) {\n          stateMachine.transition('blurred', { id: context.id });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.id })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.id });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        selector={getSelector(CONTENT_NAME)}\n        {...contentProps}\n        data-state={context.stateAttribute}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        {children}\n        <VisuallyHidden id={context.id} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHidden>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendComponent(PopperPrimitive.Arrow, 'TooltipArrow');\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const { triggerRef, id } = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id });\n    }\n  }, [id, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["stateChart","initial","context","id","states","CLOSED","on","mouseEntered","focused","WAITING_FOR_REST","onEnterState","transition","clearTimeout","restTimerId","window","setTimeout","onLeaveState","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerId","skipRestTimerElapsed","DISMISSED","TooltipContext","useTooltipContext","createContext","stateMachine","debug","warnOnUnknownTransitions","PREVIOUS_STATE","PREVIOUS_CONTEXT","CURRENT_STATE","CURRENT_CONTEXT","subscriptions","event","stateDefinition","nextState","undefined","console","warn","concat","nextStateDefinition","log","previousState","previousContext","state","forEach","callback","subscribe","push","splice","indexOf","getState","getContext","$e37f874ef74368da320cbbbb439$export$createStateMachine","$e37f874ef74368da320cbbbb439$export$stateChart","Tooltip","props","children","open","openProp","defaultOpen","onOpenChange","triggerRef","React","useRef","useId","setOpen","useControlledState","prop","defaultProp","onChange","stateAttribute","setStateAttribute","useState","useEffect","useLayoutEffect","useMemo","_react","createElement","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContext","Provider","value","displayName","TooltipTrigger","forwardRef","forwardedRef","composedTriggerRef","useComposedRefs","Primitive","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$_extends","as","selector","getSelector","type","aria-describedby","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","key","TooltipContent","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContentImpl","TooltipContentImpl","aria-label","ariaLabel","anchorRef","portalled","contentProps","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$_objectWithoutProperties","PortalWrapper","Portal","Fragment","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$CheckTriggerMoved","_radixUiReactPopper","Root","data-state","style","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$_objectSpread","--radix-tooltip-content-transform-origin","VisuallyHidden","role","TooltipArrow","extendComponent","PopperPrimitive","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.module.js.map"}
